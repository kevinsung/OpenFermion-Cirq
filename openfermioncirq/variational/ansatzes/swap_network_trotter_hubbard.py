#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

"""A variational ansatz based on a linear swap network Trotter step."""

from typing import Iterable, Optional, Sequence, Tuple, cast

import itertools

import numpy

import cirq
import openfermion

from openfermioncirq import XXYYGate, YXXYGate, swap_network
from openfermioncirq.variational.ansatz import VariationalAnsatz
from openfermioncirq.variational.letter_with_subscripts import (
        LetterWithSubscripts)


class SwapNetworkTrotterHubbardAnsatz(VariationalAnsatz):
    """An ansatz based on the fermionic swap network.
    """

    def __init__(self,
                 x_dim: float,
                 y_dim: float,
                 periodic: bool=True,
                 iterations: int=1,
                 adiabatic_evolution_time: Optional[float]=None,
                 qubits: Optional[Sequence[cirq.QubitId]]=None
                 ) -> None:
        """
        Args:
            iterations: The number of iterations of the basic template to
                include in the circuit. The number of parameters grows linearly
                with this value.
            adiabatic_evolution_time: The time scale for Hamiltonian evolution
                used to determine the default initial parameters of the ansatz.
                This is the value A from the docstring of this class.
                If not specified, defaults to the sum of the absolute values
                of the entries of the two-body tensor of the Hamiltonian.
            qubits: Qubits to be used by the ansatz circuit. If not specified,
                then qubits will automatically be generated by the
                `_generate_qubits` method.
        """
        self.x_dim = x_dim
        self.y_dim = y_dim
        self.periodic = periodic
        self.iterations = iterations
        super().__init__(qubits)

    def params(self) -> Iterable[cirq.Symbol]:
        """The parameters of the ansatz."""
        for i in range(self.iterations):
            yield LetterWithSubscripts('Th', i)
            yield LetterWithSubscripts('Tv', i)
            yield LetterWithSubscripts('V', i)

    def param_bounds(self) -> Optional[Sequence[Tuple[float, float]]]:
        """Bounds on the parameters."""
        bounds = []
        for param in self.params():
            if param.letter == 'V':
                bounds.append((-1.0, 1.0))
            else:
                bounds.append((-2.0, 2.0))
        return bounds

    def _generate_qubits(self) -> Sequence[cirq.QubitId]:
        """Produce qubits that can be used by the ansatz circuit."""
        n_qubits = 2*self.x_dim*self.y_dim
        return cirq.LineQubit.range(n_qubits)

    def operations(self, qubits: Sequence[cirq.QubitId]) -> cirq.OP_TREE:
        """Produce the operations of the ansatz circuit."""

        param_set = set(self.params())

        for i in range(self.iterations):

            # Apply one- and two-body interactions with a swap network that
            # reverses the order of the modes
            def one_and_two_body_interaction(p, q, a, b) -> cirq.OP_TREE:
                th_symbol = LetterWithSubscripts('Th', i)
                tv_symbol = LetterWithSubscripts('Tv', i)
                v_symbol = LetterWithSubscripts('V', i)
                if _is_horizontal_edge(p, q, self.x_dim, self.y_dim, self.periodic):
                    yield XXYYGate(half_turns=th_symbol).on(a, b)
                if _is_vertical_edge(p, q, self.x_dim, self.y_dim, self.periodic):
                    yield XXYYGate(half_turns=tv_symbol).on(a, b)
                if _are_same_site_opposite_spin(p, q, self.x_dim*self.y_dim):
                    yield cirq.Rot11Gate(half_turns=v_symbol).on(a, b)
            yield swap_network(
                    qubits, one_and_two_body_interaction, fermionic=True)
            qubits = qubits[::-1]

            # Apply one- and two-body interactions again. This time, reorder
            # them so that the entire iteration is symmetric
            def one_and_two_body_interaction_reversed_order(p, q, a, b
                    ) -> cirq.OP_TREE:
                th_symbol = LetterWithSubscripts('Th', i)
                tv_symbol = LetterWithSubscripts('Tv', i)
                v_symbol = LetterWithSubscripts('V', i)
                if _are_same_site_opposite_spin(p, q, self.x_dim*self.y_dim):
                    yield cirq.Rot11Gate(half_turns=v_symbol).on(a, b)
                if _is_vertical_edge(p, q, self.x_dim, self.y_dim, self.periodic):
                    yield XXYYGate(half_turns=tv_symbol).on(a, b)
                if _is_horizontal_edge(p, q, self.x_dim, self.y_dim, self.periodic):
                    yield XXYYGate(half_turns=th_symbol).on(a, b)
            yield swap_network(
                    qubits, one_and_two_body_interaction_reversed_order,
                    fermionic=True, offset=True)
            qubits = qubits[::-1]


def _is_horizontal_edge(p, q, x_dim, y_dim, periodic):
    n_sites = x_dim*y_dim
    if p >= n_sites:
        p -= n_sites
    if q >= n_sites:
        q -= n_sites
    return (q == _right_neighbor(p, x_dim, y_dim, periodic)
            or p == _right_neighbor(q, x_dim, y_dim, periodic))


def _is_vertical_edge(p, q, x_dim, y_dim, periodic):
    n_sites = x_dim*y_dim
    if p >= n_sites:
        p -= n_sites
    if q >= n_sites:
        q -= n_sites
    return (q == _bottom_neighbor(p, x_dim, y_dim, periodic)
            or p == _bottom_neighbor(q, x_dim, y_dim, periodic))


def _are_same_site_opposite_spin(p, q, n_sites):
    return abs(p-q) == n_sites


def _right_neighbor(site, x_dimension, y_dimension, periodic):
    if x_dimension == 1:
        return None
    if (site + 1) % x_dimension == 0:
        if periodic:
            return site + 1 - x_dimension
        else:
            return None
    return site + 1


def _bottom_neighbor(site, x_dimension, y_dimension, periodic):
    if y_dimension == 1:
        return None
    if site + x_dimension + 1 > x_dimension*y_dimension:
        if periodic:
            return site + x_dimension - x_dimension*y_dimension
        else:
            return None
    return site + x_dimension


def _canonicalize_exponent(exponent: float, period: int) -> float:
    # Shift into [-p/2, +p/2).
    exponent += period / 2
    exponent %= period
    exponent -= period / 2
    # Prefer (-p/2, +p/2] over [-p/2, +p/2).
    if exponent <= -period / 2:
        exponent += period  # coverage: ignore
    return exponent
